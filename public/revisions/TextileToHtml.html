<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Textile to HTML</title>

	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<style type="text/css" media="screen">
		@import url( ../Static/style.css );
	</style>
	<link rel='alternate' type='application/rss+xml' title='RSS' href='http://tom.counsell.org/rss/TextileToHtml' />
	<script src='http://tom.counsell.org/Static/newpage.js' type='text/javascript'></script>
		
</head>

<body onkeypress='hotkey(event,"http://tom.counsell.org/edit/");'>
<div id="wrapper">
	<div id="masthead">
		<div id="blogtitle" >
			Textile to HTML
		</div>
	</div>
	
	<div id="insideWrapper">
	
		<div id="sidebar">
			<div id="sidebox">
				<div class="title"><a href="../index.html" title="Tom Counsell's Soks Wiki">Tom Counsell's Soks Wiki</a></div>
			</div>
			<br />
	
			<div id="sidebox1">
				<div class="title">Key Pages</div>
				
				<a href='../index.html' class='automatic'>Home Page</a> <br/>
<a href='../view/SiteIndex.html' class='automatic'>Site Index</a> <br/>
<a href='../view/RecentChangesToThisSite.html' class=''>Recent Changes</a> <br/>
			</div>
			<br />

			<div id="sidebox4">
				<form style="padding: 0px; margin-top: 0px; margin-bottom: 0px;" id="searchform" method="get" action="http://tom.counsell.org/find/TextileToHtml">
					<div class="title">Search:</div>
					<p style="padding: 0px; margin-top: 0px; margin-bottom: 0px;">
						<input type="text" class="input" name="regex" id="search" size="15" />
						<input name="submit" type="submit" tabindex="5" value="GO" />
					</p>
				</form>
			</div>
			<br />
			
			<div id='adbox'>
				<div class='title'>Adverts</div>
				<script type="text/javascript"><!--
				google_ad_client = "pub-1825629230893907";
				google_ad_width = 120;
				google_ad_height = 90;
				google_ad_format = "120x90_0ads_al";
				google_ad_channel = "";
				google_color_border = "000000";
				google_color_bg = "000000";
				google_color_link = "FFFFFF";
				google_color_text = "CCCCCC";
				google_color_url = "999999";
				//-->
				</script>
				<script type="text/javascript"
				  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
				  </script>
<p>
</p>
			</div>
<br/>			
			<div id="sidebox2">
				<div class="title">Backlinks</div>
				
					
					
					
							
								<a href='../view/AReWriteOfRedclothTextileToHtmlConvertor.html'>A re-write of Redcloth textile to html convertor</a><br/>
							
								<a href='../view/Programming.html'>Programming</a><br/>
							
					
				
			</div>
			<br />
	
			<div id="sidebox3">
				<div class="title">Other Pages</div>
				<a href='../view/History.html' class='automatic'>History</a> <br/>
<a href='../view/Phd.html' class='automatic'>PhD</a> <br/>
<a href='../view/StuffIDoAroundTheDepartment.html' class=''>Department work</a> <br/>
<a href='../view/CollegeWork.html' class='automatic'>College work</a> <br/>
<a href='../view/Programming.html' class='automatic'>Programming</a> <br/>
			</div>
			<br />
			

	
			<div id="sidebox5">
				<div class="title">Links</div>
				<a href='http://tom.counsell.org/edit/TypeATitleHere'>Add a new page</a><br/>
				<a href='http://tom.counsell.org/edit/PictureOfTypeATitleHere'>Upload a new picture</a><br/>
				<a href='http://tom.counsell.org/edit/AttachedTypeATitleHere'>Upload a new file</a><br/>
			</div>
			<br />
	
			<div id="sidebox6">
				<div class="title"><a href='http://www.soks.org'>Soks</a> Powered</div>
				<a href='http://www.soks.org'>Soks</a> is a wiki written in ruby
			</div>  
			<br />
	</div>
	
	<div id="contentwrapper">
		<div id="content">
			<br />
			<div class="post">
			<span class='pagename'><a href='http://tom.counsell.org/meta/TextileToHtml'>Textile to HTML</a> </span>






	<div class="undochange">
		<p>Tue Aug 09 04:43:14 -0400 2005 by <a href='../view/Tamc.html'>tamc</a></p>
		<ol>	
		
				
						<li><del>77. 		[ /^\'/, '&#8216;' ], # single opening</del></li>
					
				
						<li><del>78. 		[ /^"/, '&#8220;' ], # double opening</del></li>
					
				
						<li><del>79. 		[ /\'$/, '&#8217;' ], # single closing</del></li>
					
				
						<li><del>80.        	[ /\"$/, '&#8221;' ], # double closing</del></li>
					
				
						<li><del>81.         [ /\.{3}$/, '\1&#8230;' ], # ellipsis</del></li>
					
				
						<li><del>82.         [ '--', '\1&#8212;' ], # em dash</del></li>
					
				
						<li><del>83.         [ '-&gt;', ' &rarr; ' ], # right arrow</del></li>
					
				
						<li><del>84.         [ '-$', ' &#8211; ' ], # en dash</del></li>
					
				
						<li>77. 		[ /^\'/, '‘' ], # single opening</li>
					
				
						<li>78. 		[ /^"/, '“' ], # double opening</li>
					
				
						<li>79. 		[ /\'$/, '’' ], # single closing</li>
					
				
						<li>80.        	[ /\"$/, '”' ], # double closing</li>
					
				
						<li>81.         [ /\.{3}$/, '\1…' ], # ellipsis</li>
					
				
						<li>82.         [ '--', '\1—' ], # em dash</li>
					
				
						<li>83.         [ '-&gt;', ' ? ' ], # right arrow</li>
					
				
						<li>84.         [ '-$', ' – ' ], # en dash</li>
					
				
		
				
						<li><del>86.         [ '(TM)', '&#8482;' ], # trademark</del></li>
					
				
						<li><del>87.         [ '(R)', '&#174;' ], # registered</del></li>
					
				
						<li><del>88.         [ '(C)', '&#169;' ] # copyright</del></li>
					
				
						<li>86.         [ '(TM)', '™' ], # trademark</li>
					
				
						<li>87.         [ '(R)', '®' ], # registered</li>
					
				
						<li>88.         [ '(C)', '©' ] # copyright</li>
					
				
		
				
						<li><del>492.         str.gsub!( '&', '&amp;' )</del></li>
					
				
						<li><del>493.         str.gsub!( '"', '&quot;' )</del></li>
					
				
						<li><del>494.         str.gsub!( '&lt;', '&lt;')</del></li>
					
				
						<li><del>495.         str.gsub!( '&gt;', '&gt;')</del></li>
					
				
						<li>492.         str.gsub!( '&', '&' )</li>
					
				
						<li>493.         str.gsub!( '"', '"' )</li>
					
				
						<li>494.         str.gsub!( '&lt;', '&lt;')</li>
					
				
						<li>495.         str.gsub!( '&gt;', '&gt;')</li>
					
				
					
		</ol>
		<form method=post action='http://tom.counsell.org/rollback/TextileToHtml' >
			<input name='revision' value='1' type='hidden' />
			<input name='action' value='Undo the changes above' type='submit' />
		</form>
	</div>		

	<div class="undochange">
		<p>Tue Aug 09 04:43:13 -0400 2005 by <a href='../view/Tamc.html'>tamc</a></p>
		<ol>	
		
				
						<li><del>0. content moved from [[A re-write of Redcloth textile to html convertor]]</del></li>
					
				
						<li>0. h1. Textile to HTML</li>
					
				
						<li>1. </li>
					
				
						<li>2. Textile is a markup language that is meant to make it quick and easy to write basic web pages for wikis, blogs and other uses.  Redcloth is a ruby class that converts textile to html, written by _why.  Details are at http://www.whytheluckystiff.net/ruby/redcloth/ .  Unfortunately, due to my own failings, I find it hard to understand _why's code, so I wrote a partial reimplementation bellow.  This has the benefit of (for me) being clearer and easier to extend.  The drawback is that it doesn't do all that _why's version does and is slower.  But it is here in case anyone finds it useful.</li>
					
				
						<li>3. </li>
					
				
						<li>4. &lt;pre&gt;</li>
					
				
						<li>5. &lt;code&gt;</li>
					
				
						<li>6. require 'strscan'</li>
					
				
						<li>7. </li>
					
				
						<li>8. # Note: Does not implement anything beyond that on http://hobix.com/textile/</li>
					
				
						<li>9. # i.e. No markdown, link titles, and converting out of range ASCII</li>
					
				
						<li>10. # AND IT IS MUCH SLOWER THAN REDCLOTH !!</li>
					
				
						<li>11. #</li>
					
				
						<li>12. # Bodged together in a few evenings by Tom Counsell (tamc2@cam.ac.uk)</li>
					
				
						<li>13. # Feel free to do whatever you like with the code.</li>
					
				
						<li>14. #</li>
					
				
						<li>15. # Use is the same as for Redcloth (except that none of the options work):</li>
					
				
						<li>16. # html = TextileParser.new( "textile string").to_html </li>
					
				
						<li>17. #</li>
					
				
						<li>18. class TextileParser</li>
					
				
						<li>19. 	</li>
					
				
						<li>20. 	# These are applied first</li>
					
				
						<li>21. 	BLOCK_COMMANDS = [</li>
					
				
						<li>22. 		[ /&lt;pre.*?&gt;/, :pre_tag ], </li>
					
				
						<li>23. 		[ /&lt;code.*?&gt;/, :code_tag ],</li>
					
				
						<li>24. 		[ /&lt;notextile.*?&gt;/, :notextile_tag ],</li>
					
				
						<li>25. 		[ /h(\d)(.*?)\.\s+/i, :heading_block ],</li>
					
				
						<li>26. 		[ /bq(.*?)\.\s+/i, :quote_block ],</li>
					
				
						<li>27. 		[ /(\*+|\#+)\s+/,  :list_block ],</li>
					
				
						<li>28. 		[ /table(.*?)\.\s+/i, :table_block ],</li>
					
				
						<li>29. 		[ /\|/i, :unspecified_table_block ],</li>
					
				
						<li>30. 		[ /\{.+?\}\.\s+\|/i, :unspecified_table_block ], # A styled table row		</li>
					
				
						<li>31. 		[ /p(.*?)\.\s+/i, :paragraph_block ],</li>
					
				
						<li>32. 		[ /fn(\d+)(.*?)\.\s+/i, :footnote_block ],</li>
					
				
						<li>33. 		[ /\S+/i, :unspecified_block ],</li>
					
				
						<li>34. 		[ /\s+/i, :skip ],</li>
					
				
						<li>35. 	]</li>
					
				
						<li>36. 	</li>
					
				
						<li>37. 	# Then these</li>
					
				
						<li>38. 	COMMANDS = [</li>
					
				
						<li>39. 		[ /&lt;pre.*?&gt;/, :pre_tag ], # Can be inline as well as in a block</li>
					
				
						<li>40. 		[ /&lt;code.*?&gt;/, :code_tag ],  # Can be inline as well as in a block</li>
					
				
						<li>41. 		[ /&lt;notextile.*?&gt;/, :notextile_tag ],  # Can be inline as well as in a block</li>
					
				
						<li>42. 		[ /@(\S.*?\S)@/, :quick_escape_code ], </li>
					
				
						<li>43. 		[ /"(.+?)":(\S*\w\/?)/, :textile_link ],</li>
					
				
						<li>44. 		[ /\[(.+?)\]:(\S*\w\/?)/, :textile_link_alias ],</li>
					
				
						<li>45. 		[ /!(.+?)!(\S*)/, :image_link ],</li>
					
				
						<li>46. 		[ /([A-Z0-9]+)\((.*?)\)/, :acronym ],</li>
					
				
						<li>47. 		[ /(\S+?)\[(\d+)\]/, :footnote ]</li>
					
				
						<li>48. 	]	</li>
					
				
						<li>49. 	</li>
					
				
						<li>50. 	# Bit of a bodge, but need a different definition of phrase and whitespace in a table</li>
					
				
						<li>51. 	INLINE_COMMANDS = COMMANDS + [</li>
					
				
						<li>52. 		[ /\S+/i, :phrase ],</li>
					
				
						<li>53. 		[ /\s+/i, :space ],</li>
					
				
						<li>54. 	]</li>
					
				
						<li>55. 	</li>
					
				
						<li>56. 	TABLE_INLINE_COMMANDS = COMMANDS + [</li>
					
				
						<li>57. 		[ /[^\s\t\r\n\f\|]+/i, :phrase ],</li>
					
				
						<li>58. 		[ /\s+/i, :space ],</li>
					
				
						<li>59. 	]		</li>
					
				
						<li>60. 	</li>
					
				
						<li>61. 	# Then these are applied to phrases from above</li>
					
				
						<li>62. 	PHRASE_MODIFIERS = [ </li>
					
				
						<li>63. 		[ '__', 'i' ],</li>
					
				
						<li>64. 		[ '**', 'b' ],</li>
					
				
						<li>65. 		[ '_', 'em' ],</li>
					
				
						<li>66. 		[ '*', 'strong' ],</li>
					
				
						<li>67. 		[ '??', 'cite' ],</li>
					
				
						<li>68. 		[ '-', 'del' ],</li>
					
				
						<li>69. 		[ '+', 'ins' ],</li>
					
				
						<li>70. 		[ '^', 'sup' ],</li>
					
				
						<li>71. 		[ '~', 'sub' ],</li>
					
				
						<li>72. 		[ '%', 'span' ], # How to avoid when people use % as in 3.0% growth?</li>
					
				
						<li>73. 		].collect! { |regexp,tag| [ /^#{Regexp.escape(regexp)}/, /#{Regexp.escape(regexp)}$/, tag ] }</li>
					
				
						<li>74. 			</li>
					
				
						<li>75. 	# Character substitutions done last to any words</li>
					
				
						<li>76. 	GLYPHS = [</li>
					
				
						<li>77. 		[ /^\'/, '&#8216;' ], # single opening</li>
					
				
						<li>78. 		[ /^"/, '&#8220;' ], # double opening</li>
					
				
						<li>79. 		[ /\'$/, '&#8217;' ], # single closing</li>
					
				
						<li>80.        	[ /\"$/, '&#8221;' ], # double closing</li>
					
				
						<li>81.         [ /\.{3}$/, '\1&#8230;' ], # ellipsis</li>
					
				
						<li>82.         [ '--', '\1&#8212;' ], # em dash</li>
					
				
						<li>83.         [ '-&gt;', ' &rarr; ' ], # right arrow</li>
					
				
						<li>84.         [ '-$', ' &#8211; ' ], # en dash</li>
					
				
						<li>85. </li>
					
				
						<li>86.         [ '(TM)', '&#8482;' ], # trademark</li>
					
				
						<li>87.         [ '(R)', '&#174;' ], # registered</li>
					
				
						<li>88.         [ '(C)', '&#169;' ] # copyright</li>
					
				
						<li>89.     ]</li>
					
				
						<li>90.     </li>
					
				
						<li>91. 	# This is just used to give the ouput html a more beautiful layout</li>
					
				
						<li>92. 	# All tags in here will get a newline after they are output</li>
					
				
						<li>93. 	# and the indent for following lines increased by the number</li>
					
				
						<li>94. 	INDENTING_TAGS = { 	'ul' =&gt; 1,</li>
					
				
						<li>95. 						'ol' =&gt; 1,</li>
					
				
						<li>96. 						'li' =&gt; 0,</li>
					
				
						<li>97. 						'blockquote' =&gt; 1,</li>
					
				
						<li>98. 						'table' =&gt; 1,</li>
					
				
						<li>99. 						'tr' =&gt; 1,</li>
					
				
						<li>100. 						'td' =&gt; 0,</li>
					
				
						<li>101. 						'th' =&gt; 0,</li>
					
				
						<li>102. 						'p' =&gt; 0,</li>
					
				
						<li>103. 					 }</li>
					
				
						<li>104. 	</li>
					
				
						<li>105. 	def initialize( text )</li>
					
				
						<li>106. 		@text = text</li>
					
				
						<li>107. 	end</li>
					
				
						<li>108. </li>
					
				
						<li>109. 	def to_html( settings = nil )</li>
					
				
						<li>110. 		reset</li>
					
				
						<li>111. 		convert_text</li>
					
				
						<li>112. 		return html.chomp.chomp # the tests don't have any trailing \ns</li>
					
				
						<li>113. 	end</li>
					
				
						<li>114. 	</li>
					
				
						<li>115. 	private</li>
					
				
						<li>116. 	</li>
					
				
						<li>117. 	## Methods dealing with blocks of text are called first</li>
					
				
						<li>118. 	</li>
					
				
						<li>119. 	def convert_text</li>
					
				
						<li>120. 		until @scanner.eos?</li>
					
				
						<li>121. 			send( BLOCK_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )</li>
					
				
						<li>122. 			add_to_html "\n" # Prettier html if extra space between blocks </li>
					
				
						<li>123. 		end</li>
					
				
						<li>124. 		insert_any_link_aliases</li>
					
				
						<li>125. 		html</li>
					
				
						<li>126. 	end</li>
					
				
						<li>127. 	</li>
					
				
						<li>128. 	# These are all the block commands</li>
					
				
						<li>129. 	</li>
					
				
						<li>130. 	def paragraph_block</li>
					
				
						<li>131. 		tag( 'p', parse_attributes( @scanner[1] ) ) do </li>
					
				
						<li>132. 			standard_paragraph</li>
					
				
						<li>133. 		end</li>
					
				
						<li>134. 	end</li>
					
				
						<li>135. 	</li>
					
				
						<li>136. 	def quote_block</li>
					
				
						<li>137. 		tag( "blockquote", parse_attributes( @scanner[1] ) ) do</li>
					
				
						<li>138. 			tag 'p' do</li>
					
				
						<li>139. 				standard_paragraph</li>
					
				
						<li>140. 			end</li>
					
				
						<li>141. 		end</li>
					
				
						<li>142. 	end</li>
					
				
						<li>143. 	</li>
					
				
						<li>144. 	def unspecified_block</li>
					
				
						<li>145. 		@scanner.unscan</li>
					
				
						<li>146. 		tag 'p' do</li>
					
				
						<li>147. 			standard_paragraph</li>
					
				
						<li>148. 		end</li>
					
				
						<li>149. 	end</li>
					
				
						<li>150. 		</li>
					
				
						<li>151. 	def heading_block</li>
					
				
						<li>152. 		tag( "h#{@scanner[1]}", parse_attributes( @scanner[2] ) ) do</li>
					
				
						<li>153. 			standard_line # Assume titles may only be on one line</li>
					
				
						<li>154. 		end </li>
					
				
						<li>155. 	end</li>
					
				
						<li>156. 	</li>
					
				
						<li>157. 	def list_block</li>
					
				
						<li>158. 		ordered = list_ordered? # See what sort of list we have</li>
					
				
						<li>159. 		depth = list_depth</li>
					
				
						<li>160. 		@scanner.unscan # So that the lines can be scanned individually</li>
					
				
						<li>161. 		tag( ordered ? 'ol' : 'ul' ) do</li>
					
				
						<li>162. 			list_line( ordered, depth ) until end_of_list?( depth )</li>
					
				
						<li>163. 		end</li>
					
				
						<li>164. 	end</li>
					
				
						<li>165. 	</li>
					
				
						<li>166. 	def table_block</li>
					
				
						<li>167. 		tag( 'table', parse_attributes( @scanner[1] ) ) do</li>
					
				
						<li>168. 			table_line until end_of_paragraph?</li>
					
				
						<li>169. 		end</li>
					
				
						<li>170. 	end</li>
					
				
						<li>171. 	</li>
					
				
						<li>172. 	def unspecified_table_block</li>
					
				
						<li>173. 		@scanner.unscan</li>
					
				
						<li>174. 		tag( 'table' ) do</li>
					
				
						<li>175. 			table_line until end_of_paragraph?</li>
					
				
						<li>176. 		end</li>
					
				
						<li>177. 	end</li>
					
				
						<li>178. 	</li>
					
				
						<li>179. 	def footnote_block</li>
					
				
						<li>180. 		number = @scanner[1]</li>
					
				
						<li>181. 		attributes = parse_attributes( @scanner[2] )</li>
					
				
						<li>182. 		attributes[:id] = "fn#{number}"</li>
					
				
						<li>183. 		tag 'p', attributes do</li>
					
				
						<li>184. 			add_to_html "&lt;sup&gt;#{number}&lt;/sup&gt; "</li>
					
				
						<li>185. 			standard_line until end_of_paragraph?</li>
					
				
						<li>186. 		end</li>
					
				
						<li>187. 	end</li>
					
				
						<li>188. 	</li>
					
				
						<li>189. 	# Now descend into methods dealing with lines of text</li>
					
				
						<li>190. 	</li>
					
				
						<li>191. 	def pre_tag</li>
					
				
						<li>192. 		escape_tag 'pre'</li>
					
				
						<li>193. 	end</li>
					
				
						<li>194. 	</li>
					
				
						<li>195. 	def code_tag</li>
					
				
						<li>196. 		escape_tag 'code'</li>
					
				
						<li>197. 	end</li>
					
				
						<li>198. 	</li>
					
				
						<li>199. 	def notextile_tag</li>
					
				
						<li>200. 		escape_tag 'notextile', false</li>
					
				
						<li>201. 	end</li>
					
				
						<li>202. 	</li>
					
				
						<li>203. 	# This escapes until a matching close tag</li>
					
				
						<li>204. 	def escape_tag( tag, include_tag_in_output = true )</li>
					
				
						<li>205. 		add_to_html( @scanner.matched ) if include_tag_in_output</li>
					
				
						<li>206. 		level = 1</li>
					
				
						<li>207. 		while level &gt; 0</li>
					
				
						<li>208. 			break unless @scanner.scan(/(.*?)(&lt;(\/)?#{tag}.*?&gt;)/m) # Breaks if no closing tag</li>
					
				
						<li>209. 			add_to_html( htmlesc( @scanner[1] || "" ) )</li>
					
				
						<li>210. 			level = level + ( @scanner[3] ? -1 : 1 )</li>
					
				
						<li>211. 			add_to_html( htmlesc( @scanner[2] ) ) unless level == 0</li>
					
				
						<li>212. 		end</li>
					
				
						<li>213. 		add_to_html "&lt;/#{tag}&gt;" if include_tag_in_output</li>
					
				
						<li>214. 	end</li>
					
				
						<li>215. 	</li>
					
				
						<li>216. 	def quick_escape_code</li>
					
				
						<li>217. 		tag 'code' do </li>
					
				
						<li>218. 			add_to_html( htmlesc( @scanner[1] ) )</li>
					
				
						<li>219. 		end</li>
					
				
						<li>220. 	end</li>
					
				
						<li>221. 	</li>
					
				
						<li>222. 	def list_line( ordered, depth )</li>
					
				
						<li>223. 		tag 'li' do</li>
					
				
						<li>224. 			@scanner.scan(/(#+|\*+)\s+/)</li>
					
				
						<li>225. 			if ( list_ordered? == ordered ) && ( list_depth == depth )</li>
					
				
						<li>226. 				standard_line</li>
					
				
						<li>227. 			else # Recursive for sub lists</li>
					
				
						<li>228. 				list_block</li>
					
				
						<li>229. 			end</li>
					
				
						<li>230. 		end</li>
					
				
						<li>231. 	end</li>
					
				
						<li>232. 		</li>
					
				
						<li>233. 	def table_line</li>
					
				
						<li>234. 		# Are their row attributes at that start of the line?</li>
					
				
						<li>235. 		attributes = @scanner.scan(/(\{.+?\})\.\s+/) ? parse_attributes(@scanner[1]) : {} 	</li>
					
				
						<li>236. 		@scanner.scan(/\|/) # Get rid of any leading cell opening</li>
					
				
						<li>237. 		tag( 'tr', attributes ) do </li>
					
				
						<li>238. 			table_cell until end_of_table_line?</li>
					
				
						<li>239. 		end</li>
					
				
						<li>240. 	end	</li>
					
				
						<li>241. 	</li>
					
				
						<li>242. 	def standard_paragraph</li>
					
				
						<li>243. 		until end_of_paragraph?	</li>
					
				
						<li>244. 			send( INLINE_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )</li>
					
				
						<li>245. 		end</li>
					
				
						<li>246. 	end</li>
					
				
						<li>247. 	</li>
					
				
						<li>248. 	def standard_line</li>
					
				
						<li>249. 		until end_of_line?</li>
					
				
						<li>250. 			send( INLINE_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )</li>
					
				
						<li>251. 		end</li>
					
				
						<li>252. 	end</li>
					
				
						<li>253. 	</li>
					
				
						<li>254. 	# Now descend into methods dealing with phrases</li>
					
				
						<li>255. 	</li>
					
				
						<li>256. 	def table_cell</li>
					
				
						<li>257. 		# Style defined at start of cell ?</li>
					
				
						<li>258. 		attributes = @scanner.scan(/(_)?(\S*?)\.\s*/) ?  parse_attributes(@scanner[2]) : {}</li>
					
				
						<li>259. 		tag( @scanner[1] ? 'th' : 'td', attributes) do </li>
					
				
						<li>260. 			until end_of_table_cell?</li>
					
				
						<li>261. 				send( TABLE_INLINE_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )</li>
					
				
						<li>262. 			end	</li>
					
				
						<li>263. 		end</li>
					
				
						<li>264. 	end</li>
					
				
						<li>265. 	</li>
					
				
						<li>266. 	def footnote</li>
					
				
						<li>267. 		add_to_html "#{@scanner[1]}&lt;sup&gt;&lt;a href=\"#fn#{@scanner[2]}\"&gt;#{@scanner[2]}&lt;/a&gt;&lt;/sup&gt;"</li>
					
				
						<li>268. 	end</li>
					
				
						<li>269. 	</li>
					
				
						<li>270. 	def acronym</li>
					
				
						<li>271. 		add_to_html "&lt;acronym title=\"#{@scanner[2]}\"&gt;#{@scanner[1]}&lt;/acronym&gt;"</li>
					
				
						<li>272. 	end</li>
					
				
						<li>273. 	</li>
					
				
						<li>274. 	def phrase</li>
					
				
						<li>275. 		word = @scanner.matched</li>
					
				
						<li>276. 		</li>
					
				
						<li>277. 		return add_to_html( parse_glyphs( word ) ) unless word =~ /\w+/ # If a word is entirely symbols then we will leave it in peace.</li>
					
				
						<li>278. 		</li>
					
				
						<li>279. 		# Open tags</li>
					
				
						<li>280. 		PHRASE_MODIFIERS.each do |start_r, end_r, tag|</li>
					
				
						<li>281. 			if word =~ start_r</li>
					
				
						<li>282. 				word = $' # The bit after the match</li>
					
				
						<li>283. 				# Look for matching brackets that indicate there are attributes</li>
					
				
						<li>284. 				if word =~ /(\(.+?\)|\{.+?\}|\[.+?\])/ 				</li>
					
				
						<li>285. 					open_tag( tag, parse_attributes( $1 ) )</li>
					
				
						<li>286. 					word = $'</li>
					
				
						<li>287. 				else</li>
					
				
						<li>288. 					open_tag tag</li>
					
				
						<li>289. 				end</li>
					
				
						<li>290. 				break</li>
					
				
						<li>291. 			end</li>
					
				
						<li>292. 		end</li>
					
				
						<li>293. 		</li>
					
				
						<li>294. 		# Close tags</li>
					
				
						<li>295. 		end_tag = nil</li>
					
				
						<li>296. 		PHRASE_MODIFIERS.each do |start_r, end_r, tag|</li>
					
				
						<li>297. 			if word =~ end_r</li>
					
				
						<li>298. 				end_tag = tag</li>
					
				
						<li>299. 				word = $` # The bit before the match</li>
					
				
						<li>300. 				break</li>
					
				
						<li>301. 			end</li>
					
				
						<li>302. 		end</li>
					
				
						<li>303. 		add_to_html parse_glyphs( word )</li>
					
				
						<li>304. 		close_tag( end_tag ) if end_tag</li>
					
				
						<li>305. 	end</li>
					
				
						<li>306. 	</li>
					
				
						<li>307. 	def space</li>
					
				
						<li>308. 		add_to_html @scanner.matched</li>
					
				
						<li>309. 	end</li>
					
				
						<li>310. 		</li>
					
				
						<li>311. 	def image_link</li>
					
				
						<li>312. 		@scanner.matched =~ /^!([&lt;&gt;]*)(.*?)(!|\((.*?)\)!)($|(:(.+?)$))/</li>
					
				
						<li>313. 		alignment, src, title, url = $1, $2, $4, $7</li>
					
				
						<li>314. 		attributes = {}</li>
					
				
						<li>315. 		attributes[:style] = 'float:right' if alignment == '&gt;'</li>
					
				
						<li>316. 		attributes[:style] = 'float:left' if alignment == '&lt;'</li>
					
				
						<li>317. </li>
					
				
						<li>318. 		attributes[:src] = src</li>
					
				
						<li>319. 		attributes[:alt] = attributes[ :title ] = title if title</li>
					
				
						<li>320. 		if url</li>
					
				
						<li>321. 			tag 'a', { :href =&gt; url } do</li>
					
				
						<li>322. 				open_tag 'img', attributes, true</li>
					
				
						<li>323. 			end</li>
					
				
						<li>324. 		else</li>
					
				
						<li>325. 			open_tag 'img', attributes, true</li>
					
				
						<li>326. 		end	</li>
					
				
						<li>327. 	end</li>
					
				
						<li>328. 	</li>
					
				
						<li>329. 	def skip</li>
					
				
						<li>330. 		# Do nothing !</li>
					
				
						<li>331. 	end</li>
					
				
						<li>332. 	</li>
					
				
						<li>333. 	def textile_link</li>
					
				
						<li>334. 		add_to_html "&lt;a href=\"#{@scanner[2]}\"&gt;#{@scanner[1]}&lt;/a&gt;"</li>
					
				
						<li>335. 	end</li>
					
				
						<li>336. 	</li>
					
				
						<li>337. 	def textile_link_alias</li>
					
				
						<li>338. 		# These are saved for later resubstitution</li>
					
				
						<li>339. 		@aliases[ @scanner[1] ] = @scanner[2]</li>
					
				
						<li>340. 	end</li>
					
				
						<li>341. 	</li>
					
				
						<li>342. 	# These feels clunky, and is done last</li>
					
				
						<li>343. 	def insert_any_link_aliases</li>
					
				
						<li>344. 		@aliases.each do |als, href|</li>
					
				
						<li>345. 			html.gsub!( /href="#{als}"/, "href=\"#{href}\"" )</li>
					
				
						<li>346. 		end</li>
					
				
						<li>347. 	end</li>
					
				
						<li>348. 	</li>
					
				
						<li>349. 	# These are helper methods that make sure html is properly closed and indented</li>
					
				
						<li>350. 	</li>
					
				
						<li>351. 	def tag( tag, attributes = {} )</li>
					
				
						<li>352. 		open_tag( tag, attributes )</li>
					
				
						<li>353. 		yield</li>
					
				
						<li>354. 		close_tag tag</li>
					
				
						<li>355. 	end</li>
					
				
						<li>356. 	</li>
					
				
						<li>357. 	def close_tag( tag = :all_tags )</li>
					
				
						<li>358. 		# Check the tag has been opened</li>
					
				
						<li>359. 		return unless open_tags.include?( tag ) || ( tag == :all_tags )</li>
					
				
						<li>360. 		</li>
					
				
						<li>361. 		# Close all tags up to that tag (in case one was not closed)</li>
					
				
						<li>362. 		until open_tags.empty?</li>
					
				
						<li>363. 			open_tag = open_tags.pop</li>
					
				
						<li>364. 			# This is just stuff to make the html look pretty</li>
					
				
						<li>365. 			if (indent = INDENTING_TAGS[ open_tag ] ) </li>
					
				
						<li>366. 				if indent == 0</li>
					
				
						<li>367. 					add_to_html "&lt;/#{open_tag}&gt;"</li>
					
				
						<li>368. 					add_to_html "\n"</li>
					
				
						<li>369. 				else</li>
					
				
						<li>370. 					add_to_html "\n" unless html =~ /\n$/</li>
					
				
						<li>371. 					@indent -= indent</li>
					
				
						<li>372. 					add_to_html( "\t" * @indent )</li>
					
				
						<li>373. 					add_to_html "&lt;/#{open_tag}&gt;"</li>
					
				
						<li>374. 					add_to_html "\n"</li>
					
				
						<li>375. 				end</li>
					
				
						<li>376. 			else</li>
					
				
						<li>377. 				add_to_html "&lt;/#{open_tag}&gt;"</li>
					
				
						<li>378. 			end</li>
					
				
						<li>379. 			return if open_tag == tag</li>
					
				
						<li>380. 		end</li>
					
				
						<li>381. 	end</li>
					
				
						<li>382. 	</li>
					
				
						<li>383. 	def open_tag( tag, attributes = {}, no_close_tag = false )</li>
					
				
						<li>384. 		add_to_html( "\t" * @indent )</li>
					
				
						<li>385. 		</li>
					
				
						<li>386. 		add_to_html "&lt;#{tag}"</li>
					
				
						<li>387. 		</li>
					
				
						<li>388. 		attributes.each { |key, value| 	add_to_html( " #{key.to_s}=\"#{value.to_s}\"" )	}</li>
					
				
						<li>389. 		</li>
					
				
						<li>390. 		if no_close_tag</li>
					
				
						<li>391. 			add_to_html " /&gt;"</li>
					
				
						<li>392. 			return</li>
					
				
						<li>393. 		end</li>
					
				
						<li>394. 		</li>
					
				
						<li>395. 		add_to_html "&gt;"</li>
					
				
						<li>396. 		</li>
					
				
						<li>397. 		if (indent = INDENTING_TAGS[ tag ] )			</li>
					
				
						<li>398. 			add_to_html "\n" unless indent == 0</li>
					
				
						<li>399. 			@indent += indent</li>
					
				
						<li>400. 		end</li>
					
				
						<li>401. 		open_tags &lt;&lt; tag</li>
					
				
						<li>402. 	end</li>
					
				
						<li>403. 	</li>
					
				
						<li>404. 	def open_tags</li>
					
				
						<li>405. 		@open_tags ||= []</li>
					
				
						<li>406. 	end</li>
					
				
						<li>407. 	</li>
					
				
						<li>408. 	def parse_attributes( attribute_text )</li>
					
				
						<li>409. 		return {} unless attribute_text && attribute_text != ""</li>
					
				
						<li>410. 		a = { :style =&gt; "" }</li>
					
				
						<li>411. 		</li>
					
				
						<li>412. 		# The hand-entered classes, ids, styles and langs</li>
					
				
						<li>413. 		# These are replaced with "" so their content cannot be matched below</li>
					
				
						<li>414. 		a[:lang] = $1 if attribute_text =~ /\[(.+?)\]/</li>
					
				
						<li>415. 		a[:class] = $1 if attribute_text.sub!(/\((.+?)\)/,'')</li>
					
				
						<li>416. 		a[:class], a[:id] = $1, $2 if a[:class] =~  /^(.*?)#(.*)$/</li>
					
				
						<li>417. 		a[:style] &lt;&lt; "#{$1};" if attribute_text.sub!(/\{(.+?)\}/,'')</li>
					
				
						<li>418. </li>
					
				
						<li>419. 		# Various padding and indents</li>
					
				
						<li>420. 		a[:style] &lt;&lt; "padding-left:#{ $1.length }em;" if attribute_text =~ /(\(+)/</li>
					
				
						<li>421. 		a[:style] &lt;&lt; "padding-right:#{ $1.length }em;" if attribute_text =~ /(\)+)/		</li>
					
				
						<li>422. </li>
					
				
						<li>423. 		# The various alignments</li>
					
				
						<li>424. 		a[:style] &lt;&lt; "text-align:left;" if attribute_text =~ /&lt;(?!&gt;)/</li>
					
				
						<li>425. 		a[:style] &lt;&lt; "text-align:right;" if attribute_text =~ /(?!&lt;)&gt;/</li>
					
				
						<li>426. 		a[:style] &lt;&lt; "text-align:justify;" if attribute_text =~ /&lt;&gt;/</li>
					
				
						<li>427. 		a[:style] &lt;&lt; "text-align:center;" if attribute_text =~ /=/</li>
					
				
						<li>428. 		</li>
					
				
						<li>429. 		#Various column spans on tables</li>
					
				
						<li>430. 		a[:colspan] = $1 if attribute_text =~ /\\(\d+)/</li>
					
				
						<li>431. 		a[:rowspan] = $1 if attribute_text =~ /\/(\d+)/</li>
					
				
						<li>432. 		</li>
					
				
						<li>433. 		#Vertical alignments on tables</li>
					
				
						<li>434. 		a[:style] &lt;&lt; "vertical-align:top;" if attribute_text =~ /\^/</li>
					
				
						<li>435. 		a[:style] &lt;&lt; "vertical-align:bottom;" if attribute_text =~ /\~/</li>
					
				
						<li>436. 		</li>
					
				
						<li>437. 		# Get rid of any empty attributes before returning</li>
					
				
						<li>438. 		a.delete_if { |k,v| !v || (v == "") }</li>
					
				
						<li>439. 	end</li>
					
				
						<li>440. 	</li>
					
				
						<li>441. 	def parse_glyphs( word )</li>
					
				
						<li>442. 		GLYPHS.each do |regexp,replacement|</li>
					
				
						<li>443. 			word.gsub!( regexp, replacement )</li>
					
				
						<li>444. 		end</li>
					
				
						<li>445. 		word</li>
					
				
						<li>446. 	end</li>
					
				
						<li>447. 	</li>
					
				
						<li>448. 	# Now some helper methods for spotting the ends of sections</li>
					
				
						<li>449. 	</li>
					
				
						<li>450. 	def end_of_paragraph?</li>
					
				
						<li>451. 		return true if @scanner.eos?</li>
					
				
						<li>452. 		@scanner.scan(/\n{2,}/)</li>
					
				
						<li>453. 	end</li>
					
				
						<li>454. 	</li>
					
				
						<li>455. 	def end_of_list?( depth )</li>
					
				
						<li>456. 		return true if @scanner.eos?</li>
					
				
						<li>457. 		return true unless @scanner.check(/(#+|\*+)\s+/) # Not a list any more</li>
					
				
						<li>458. 		return true if list_depth &lt; depth # End of this sub list</li>
					
				
						<li>459. 		@scanner.scan(/\n{2,}/)</li>
					
				
						<li>460. 	end</li>
					
				
						<li>461. 	</li>
					
				
						<li>462. 	def end_of_line?</li>
					
				
						<li>463. 		return true if @scanner.eos?</li>
					
				
						<li>464. 		return true if @scanner.check(/\n{2,}/)</li>
					
				
						<li>465. 		@scanner.scan(/\n/)</li>
					
				
						<li>466. 	end</li>
					
				
						<li>467. 	</li>
					
				
						<li>468. 	def end_of_table_line?</li>
					
				
						<li>469. 		return true if @scanner.eos?</li>
					
				
						<li>470. 		return true if @scanner.check(/\n{2,}/)</li>
					
				
						<li>471. 		@scanner.scan(/\|\s*\n/)</li>
					
				
						<li>472. 	end</li>
					
				
						<li>473. 	</li>
					
				
						<li>474. 	def end_of_table_cell?</li>
					
				
						<li>475. 		return true if @scanner.eos?</li>
					
				
						<li>476. 		return true if @scanner.check(/\n/)</li>
					
				
						<li>477. 		return true if @scanner.check(/\|\s*\n/)</li>
					
				
						<li>478. 		@scanner.scan(/\|/)</li>
					
				
						<li>479. 	end</li>
					
				
						<li>480. 	</li>
					
				
						<li>481. 	# Now some random helper methods for decoding</li>
					
				
						<li>482. 	</li>
					
				
						<li>483. 	def list_ordered?</li>
					
				
						<li>484. 		@scanner.matched[0,1] == '#'</li>
					
				
						<li>485. 	end</li>
					
				
						<li>486. 	</li>
					
				
						<li>487. 	def list_depth</li>
					
				
						<li>488. 		@scanner[1].size</li>
					
				
						<li>489. 	end</li>
					
				
						<li>490. 	</li>
					
				
						<li>491. 	def htmlesc( str )</li>
					
				
						<li>492.         str.gsub!( '&', '&amp;' )</li>
					
				
						<li>493.         str.gsub!( '"', '&quot;' )</li>
					
				
						<li>494.         str.gsub!( '&lt;', '&lt;')</li>
					
				
						<li>495.         str.gsub!( '&gt;', '&gt;')</li>
					
				
						<li>496.         str</li>
					
				
						<li>497.     end</li>
					
				
						<li>498. 	</li>
					
				
						<li>499. 	# Now the low level matching functions</li>
					
				
						<li>500. 	</li>
					
				
						<li>501. 	def add_to_html( object )</li>
					
				
						<li>502. 		@html &lt;&lt; object.to_s</li>
					
				
						<li>503. 	end</li>
					
				
						<li>504. 	</li>
					
				
						<li>505. 	def html</li>
					
				
						<li>506. 		@html</li>
					
				
						<li>507. 	end</li>
					
				
						<li>508. 	</li>
					
				
						<li>509. 	def reset</li>
					
				
						<li>510. 		@html, @scanner = "" , StringScanner.new( @text )</li>
					
				
						<li>511. 		@aliases = {}</li>
					
				
						<li>512. 		@indent = 0</li>
					
				
						<li>513. 	end	</li>
					
				
						<li>514. end</li>
					
				
						<li>515. &lt;/code&gt;</li>
					
				
						<li>516. &lt;/pre&gt;</li>
					
				
					
		</ol>
		<form method=post action='http://tom.counsell.org/rollback/TextileToHtml' >
			<input name='revision' value='0' type='hidden' />
			<input name='action' value='Undo the changes above' type='submit' />
		</form>
	</div>		

	<div class="undochange">
		<p>Tue Aug 09 04:43:13 -0400 2005 by <a href='../view/Tamc.html'>tamc</a></p>
		<ol>	
		
				
						<li>0. content moved from [[A re-write of Redcloth textile to html convertor]]</li>
					
				
					
		</ol>
		<form method=post action='http://tom.counsell.org/rollback/TextileToHtml' >
			<input name='revision' value='-1' type='hidden' />
			<input name='action' value='Undo the changes above' type='submit' />
		</form>
	</div>		



<div class='command'>
	<a href='http://tom.counsell.org/edit/TextileToHtml' accesskey="R" >Return to editing</a>
</div>

			<br />
		</div>
		<br />
	</div>
</div>



<div id="footer">

 <br />From an original theme on <a class="footerLink" href='http://wordpress.org' title='Proudly powered by WordPress, state-of-the-art semantic personal publishing platform'>WordPress 1.5</a>. <br />

This theme started out as <a class="footerLink" href="http://www.thoughtmechanics.com/blog/templates">Benevolence</a><br /> and ended up as  <a class="footerLink" href="http://theloo.org/2005/03/06/borderline-chaos/">Borderline Chaos (1.9)</a>.  <br />It validates in <a class="footerLink" href="http://validator.w3.org/check/referer">XHTML</a> and <a class="footerLink" href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a> minus plugins.
<br />

<a class="footerLink" href="http://www.managedtasks.com/wpthemes/blog">WordPress 1.5 Themes</a> is &copy; the Author. 


<br /><br />

</div>



</div>


</div>
</body>

</html>
