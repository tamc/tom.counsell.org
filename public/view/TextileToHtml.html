<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Textile to HTML</title>
  <link rel="stylesheet" href="/index.css">
</head>
<body>
  <header>
    <h1>Textile to HTML</h1>
  </header>
  <p>Textile is a markup language that is meant to make it quick and easy to write basic web pages for wikis, blogs and other uses. Redcloth is a <a href="Ruby.html">ruby</a> class that converts textile to html, written by _why. Details are at <a href="http://www.whytheluckystiff.net/ruby/redcloth/">http://www.whytheluckystiff.net/ruby/redcloth/</a> . Unfortunately, due to my own failings, I find it hard to understand _why’s code, so I wrote a partial reimplementation bellow. This has the benefit of (for me) being clearer and easier to extend. The drawback is that it doesn’t do all that _why’s version does and is slower. But it is here in case anyone finds it useful.</p>
<pre><code>require &#39;strscan&#39;

# Note: Does not implement anything beyond that on http://hobix.com/textile/
# i.e. No markdown, link titles, and converting out of range ASCII
# AND IT IS MUCH SLOWER THAN REDCLOTH !!
#
# Bodged together in a few evenings by Tom Counsell (tamc2@cam.ac.uk)
# Feel free to do whatever you like with the code.
#
# Use is the same as for Redcloth (except that none of the options work):
# html = TextileParser.new( &quot;textile string&quot;).to_html 
#
class TextileParser

    # These are applied first
    BLOCK_COMMANDS = [
        [ /&lt;pre.*?&gt;/, :pre_tag ], 
        [ /&lt;code.*?&gt;/, :code_tag ],
        [ //, :notextile_tag ],
        [ /h(\d)(.*?)\.\s+/i, :heading_block ],
        [ /bq(.*?)\.\s+/i, :quote_block ],
        [ /(\*+|\#+)\s+/,  :list_block ],
        [ /table(.*?)\.\s+/i, :table_block ],
        [ /\|/i, :unspecified_table_block ],
        [ /\{.+?\}\.\s+\|/i, :unspecified_table_block ], #�A styled table row        
        [ /p(.*?)\.\s+/i, :paragraph_block ],
        [ /fn(\d+)(.*?)\.\s+/i, :footnote_block ],
        [ /\S+/i, :unspecified_block ],
        [ /\s+/i, :skip ],
    ]

    # Then these
    COMMANDS = [
        [ //, :pre_tag ], # Can be inline as well as in a block
        [ //, :code_tag ],  # Can be inline as well as in a block
        [ //, :notextile_tag ],  # Can be inline as well as in a block
        [ /@(\S.*?\S)@/, :quick_escape_code ], 
        [ /&quot;(.+?)&quot;:(\S*\w\/?)/, :textile_link ],
        [ /\[(.+?)\]:(\S*\w\/?)/, :textile_link_alias ],
        [ /!(.+?)!(\S*)/, :image_link ],
        [ /([A-Z0-9]+)\((.*?)\)/, :acronym ],
        [ /(\S+?)\[(\d+)\]/, :footnote ]
    ]    

    # Bit of a bodge, but need a different definition of phrase and whitespace in a table
    INLINE_COMMANDS = COMMANDS + [
        [ /\S+/i, :phrase ],
        [ /\s+/i, :space ],
    ]

    TABLE_INLINE_COMMANDS = COMMANDS + [
        [ /[^\s\t\r\n\f\|]+/i, :phrase ],
        [ /\s+/i, :space ],
    ]        

    # Then these are applied to phrases from above
    PHRASE_MODIFIERS = [ 
        [ &#39;__&#39;, &#39;i&#39; ],
        [ &#39;**&#39;, &#39;b&#39; ],
        [ &#39;_&#39;, &#39;em&#39; ],
        [ &#39;*&#39;, &#39;strong&#39; ],
        [ &#39;??&#39;, &#39;cite&#39; ],
        [ &#39;-&#39;, &#39;del&#39; ],
        [ &#39;+&#39;, &#39;ins&#39; ],
        [ &#39;^&#39;, &#39;sup&#39; ],
        [ &#39;~&#39;, &#39;sub&#39; ],
        [ &#39;%&#39;, &#39;span&#39; ], # How to avoid when people use % as in 3.0% growth?
        ].collect! { |regexp,tag| [ /^#{Regexp.escape(regexp)}/, /#{Regexp.escape(regexp)}$/, tag ] }

    # Character substitutions done last to any words
    GLYPHS = [
        [ /^\&#39;/, &#39;�&#39; ], # single opening
        [ /^&quot;/, &#39;�&#39; ], # double opening
        [ /\&#39;$/, &#39;�&#39; ], # single closing
           [ /\&quot;$/, &#39;�&#39; ], # double closing
        [ /\.{3}$/, &#39;\1�&#39; ], # ellipsis
        [ &#39;--&#39;, &#39;\1�&#39; ], # em dash
        [ &#39;-&gt;&#39;, &#39; ? &#39; ], # right arrow
        [ &#39;-$&#39;, &#39; � &#39; ], # en dash

        [ &#39;(TM)&#39;, &#39;�&#39; ], # trademark
        [ &#39;(R)&#39;, &#39;�&#39; ], # registered
        [ &#39;(C)&#39;, &#39;�&#39; ] # copyright
    ]

    # This is just used to give the ouput html a more beautiful layout
    # All tags in here will get a newline after they are output
    # and the indent for following lines increased by the number
    INDENTING_TAGS = {     &#39;ul&#39; =&gt; 1,
                        &#39;ol&#39; =&gt; 1,
                        &#39;li&#39; =&gt; 0,
                        &#39;blockquote&#39; =&gt; 1,
                        &#39;table&#39; =&gt; 1,
                        &#39;tr&#39; =&gt; 1,
                        &#39;td&#39; =&gt; 0,
                        &#39;th&#39; =&gt; 0,
                        &#39;p&#39; =&gt; 0,
                     }

    def initialize( text )
        @text = text
    end

    def to_html( settings = nil )
        reset
        convert_text
        return html.chomp.chomp # the tests don&#39;t have any trailing \ns
    end

    private

    ## Methods dealing with blocks of text are called first

    def convert_text
        until @scanner.eos?
            send( BLOCK_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )
            add_to_html &quot;\n&quot; # Prettier html if extra space between blocks 
        end
        insert_any_link_aliases
        html
    end

    # These are all the block commands

    def paragraph_block
        tag( &#39;p&#39;, parse_attributes( @scanner[1] ) ) do 
            standard_paragraph
        end
    end

    def quote_block
        tag( &quot;blockquote&quot;, parse_attributes( @scanner[1] ) ) do
            tag &#39;p&#39; do
                standard_paragraph
            end
        end
    end

    def unspecified_block
        @scanner.unscan
        tag &#39;p&#39; do
            standard_paragraph
        end
    end

    def heading_block
        tag( &quot;h#{@scanner[1]}&quot;, parse_attributes( @scanner[2] ) ) do
            standard_line # Assume titles may only be on one line
        end 
    end

    def list_block
        ordered = list_ordered? # See what sort of list we have
        depth = list_depth
        @scanner.unscan # So that the lines can be scanned individually
        tag( ordered ? &#39;ol&#39; : &#39;ul&#39; ) do
            list_line( ordered, depth ) until end_of_list?( depth )
        end
    end

    def table_block
        tag( &#39;table&#39;, parse_attributes( @scanner[1] ) ) do
            table_line until end_of_paragraph?
        end
    end

    def unspecified_table_block
        @scanner.unscan
        tag( &#39;table&#39; ) do
            table_line until end_of_paragraph?
        end
    end

    def footnote_block
        number = @scanner[1]
        attributes = parse_attributes( @scanner[2] )
        attributes[:id] = &quot;fn#{number}&quot; 
        tag &#39;p&#39;, attributes do
            add_to_html &quot;#{number} &quot; 
            standard_line until end_of_paragraph?
        end
    end

    # Now descend into methods dealing with lines of text

    def pre_tag
        escape_tag &#39;pre&#39;
    end

    def code_tag
        escape_tag &#39;code&#39;
    end

    def notextile_tag
        escape_tag &#39;notextile&#39;, false
    end

    # This escapes until a matching close tag
    def escape_tag( tag, include_tag_in_output = true )
        add_to_html( @scanner.matched ) if include_tag_in_output
        level = 1
        while level &gt; 0
            break unless @scanner.scan(/(.*?)(&lt;(\/)?#{tag}.*?&gt;)/m) # Breaks if no closing tag
            add_to_html( htmlesc( @scanner[1] || &quot;&quot; ) )
            level = level + ( @scanner[3] ? -1 : 1 )
            add_to_html( htmlesc( @scanner[2] ) ) unless level  0
        end
        add_to_html &quot;&quot; if include_tag_in_output
    end

    def quick_escape_code
        tag &#39;code&#39; do 
            add_to_html( htmlesc( @scanner[1] ) )
        end
    end

    def list_line( ordered, depth )
        tag &#39;li&#39; do
            @scanner.scan(/(#+|\*+)\s+/)
            if ( list_ordered?  ordered ) &amp;&amp; ( list_depth == depth )
                standard_line
            else # Recursive for sub lists
                list_block
            end
        end
    end

    def table_line
        # Are their row attributes at that start of the line?
        attributes = @scanner.scan(/(\{.+?\})\.\s+/) ? parse_attributes(@scanner[1]) : {}     
        @scanner.scan(/\|/) # Get rid of any leading cell opening
        tag( &#39;tr&#39;, attributes ) do 
            table_cell until end_of_table_line?
        end
    end    

    def standard_paragraph
        until end_of_paragraph?    
            send( INLINE_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )
        end
    end

    def standard_line
        until end_of_line?
            send( INLINE_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )
        end
    end

    # Now descend into methods dealing with phrases

    def table_cell
        # Style defined at start of cell ?
        attributes = @scanner.scan(/(_)?(\S*?)\.\s*/) ?  parse_attributes(@scanner[2]) : {}
        tag( @scanner[1] ? &#39;th&#39; : &#39;td&#39;, attributes) do 
            until end_of_table_cell?
                send( TABLE_INLINE_COMMANDS.detect { |regexp, method| @scanner.scan( regexp ) }[1] )
            end    
        end
    end

    def footnote
        add_to_html &quot;#{@scanner[1]}#{@scanner[2]}&quot; 
    end

    def acronym
        add_to_html &quot;#{@scanner[1]}&quot; 
    end

    def phrase
        word = @scanner.matched

        return add_to_html( parse_glyphs( word ) ) unless word =~ /\w+/ # If a word is entirely symbols then we will leave it in peace.

        # Open tags
        PHRASE_MODIFIERS.each do |start_r, end_r, tag|
            if word =~ start_r
                word = $&#39; # The bit after the match
                # Look for matching brackets that indicate there are attributes
                if word =~ /(\(.+?\)|\{.+?\}|\[.+?\])/                 
                    open_tag( tag, parse_attributes( $1 ) )
                    word = $&#39;
                else
                    open_tag tag
                end
                break
            end
        end

        # Close tags
        end_tag = nil
        PHRASE_MODIFIERS.each do |start_r, end_r, tag|
            if word =~ end_r
                end_tag = tag
                word = $` # The bit before the match
                break
            end
        end
        add_to_html parse_glyphs( word )
        close_tag( end_tag ) if end_tag
    end

    def space
        add_to_html @scanner.matched
    end

    def image_link
        @scanner.matched =~ /^!([&lt;&gt;]*)(.*?)(!|\((.*?)\)!)($|(:(.+?)$))/
        alignment, src, title, url = $1, $2, $4, $7
        attributes = {}
        attributes[:style] = &#39;float:right&#39; if alignment  &#39;&gt;&#39;
        attributes[:style] = &#39;float:left&#39; if alignment  &#39;&lt;&#39;

        attributes[:src] = src
        attributes[:alt] = attributes[ :title ] = title if title
        if url
            tag &#39;a&#39;, { :href =&gt; url } do
                open_tag &#39;img&#39;, attributes, true
            end
        else
            open_tag &#39;img&#39;, attributes, true
        end    
    end

    def skip
        # Do nothing !
    end

    def textile_link
        add_to_html &quot;#{@scanner[1]}&quot; 
    end

    def textile_link_alias
        # These are saved for later resubstitution
        @aliases[ @scanner[1] ] = @scanner[2]
    end

    # These feels clunky, and is done last
    def insert_any_link_aliases
        @aliases.each do |als, href|
            html.gsub!( /href=&quot;#{als}&quot;/, &quot;href=\&quot;#{href}\&quot;&quot; )
        end
    end

    # These are helper methods that make sure html is properly closed and indented

    def tag( tag, attributes = {} )
        open_tag( tag, attributes )
        yield
        close_tag tag
    end

    def close_tag( tag = :all_tags )
        # Check the tag has been opened
        return unless open_tags.include?( tag ) || ( tag == :all_tags )

        # Close all tags up to that tag (in case one was not closed)
        until open_tags.empty?
            open_tag = open_tags.pop
            # This is just stuff to make the html look pretty
            if (indent = INDENTING_TAGS[ open_tag ] ) 
                if indent == 0
                    add_to_html &quot;&quot; 
                    add_to_html &quot;\n&quot; 
                else
                    add_to_html &quot;\n&quot; unless html =~ /\n$/
                    @indent -= indent
                    add_to_html( &quot;\t&quot; * @indent )
                    add_to_html &quot;&quot; 
                    add_to_html &quot;\n&quot; 
                end
            else
                add_to_html &quot;&quot; 
            end
            return if open_tag == tag
        end
    end

    def open_tag( tag, attributes = {}, no_close_tag = false )
        add_to_html( &quot;\t&quot; * @indent )

        add_to_html &quot;&lt;#{tag}&quot; 

        attributes.each { |key, value|     add_to_html( &quot; #{key.to_s}=\&quot;#{value.to_s}\&quot;&quot; )    }

        if no_close_tag
            add_to_html &quot; /&gt;&quot; 
            return
        end

        add_to_html &quot;&gt;&quot; 

        if (indent = INDENTING_TAGS[ tag ] )            
            add_to_html &quot;\n&quot; unless indent == 0
            @indent += indent
        end
        open_tags &lt;&lt; tag
    end

    def open_tags
        @open_tags ||= []
    end

    def parse_attributes( attribute_text )
        return {} unless attribute_text &amp;&amp; attribute_text != &quot;&quot; 
        a = { :style =&gt; &quot;&quot; }

        # The hand-entered classes, ids, styles and langs
        # These are replaced with &quot;&quot; so their content cannot be matched below
        a[:lang] = $1 if attribute_text =~ /\[(.+?)\]/
        a[:class] = $1 if attribute_text.sub!(/\((.+?)\)/,&#39;&#39;)
        a[:class], a[:id] = $1, $2 if a[:class] =~  /^(.*?)#(.*)$/
        a[:style] &lt;&lt; &quot;#{$1};&quot; if attribute_text.sub!(/\{(.+?)\}/,&#39;&#39;)

        # Various padding and indents
        a[:style] &lt;&lt; &quot;padding-left:#{ $1.length }em;&quot; if attribute_text =~ /(\(+)/
        a[:style] &lt;&lt; &quot;padding-right:#{ $1.length }em;&quot; if attribute_text =~ /(\)+)/        

        # The various alignments
        a[:style] &lt;&lt; &quot;text-align:left;&quot; if attribute_text =~ /&lt;(?!&gt;)/
        a[:style] &lt;&lt; &quot;text-align:right;&quot; if attribute_text =~ /(?!&lt;)&gt;/
        a[:style] &lt;&lt; &quot;text-align:justify;&quot; if attribute_text =~ /&lt;&gt;/
        a[:style] &lt;&lt; &quot;text-align:center;&quot; if attribute_text =~ /=/

        #Various column spans on tables
        a[:colspan] = $1 if attribute_text =~ /\\(\d+)/
        a[:rowspan] = $1 if attribute_text =~ /\/(\d+)/

        #Vertical alignments on tables
        a[:style] &lt;&lt; &quot;vertical-align:top;&quot; if attribute_text =~ /\^/
        a[:style] &lt;&lt; &quot;vertical-align:bottom;&quot; if attribute_text =~ /\~/

        # Get rid of any empty attributes before returning
        a.delete_if { |k,v| !v || (v  &quot;&quot;) }
    end

    def parse_glyphs( word )
        GLYPHS.each do |regexp,replacement|
            word.gsub!( regexp, replacement )
        end
        word
    end

    # Now some helper methods for spotting the ends of sections

    def end_of_paragraph?
        return true if @scanner.eos?
        @scanner.scan(/\n{2,}/)
    end

    def end_of_list?( depth )
        return true if @scanner.eos?
        return true unless @scanner.check(/(#+|\*+)\s+/) # Not a list any more
        return true if list_depth &lt; depth # End of this sub list
        @scanner.scan(/\n{2,}/)
    end

    def end_of_line?
        return true if @scanner.eos?
        return true if @scanner.check(/\n{2,}/)
        @scanner.scan(/\n/)
    end

    def end_of_table_line?
        return true if @scanner.eos?
        return true if @scanner.check(/\n{2,}/)
        @scanner.scan(/\|\s*\n/)
    end

    def end_of_table_cell?
        return true if @scanner.eos?
        return true if @scanner.check(/\n/)
        return true if @scanner.check(/\|\s*\n/)
        @scanner.scan(/\|/)
    end

    # Now some random helper methods for decoding

    def list_ordered?
        @scanner.matched[0,1]  &#39;#&#39;
    end

    def list_depth
        @scanner[1].size
    end

    def htmlesc( str )
        str.gsub!( &#39;&amp;&#39;, &#39;&amp;&#39; )
        str.gsub!( &#39;&quot;&#39;, &#39;&quot;&#39; )
        str.gsub!( &#39;&lt;&#39;, &#39;&lt;&#39;)
        str.gsub!( &#39;&gt;&#39;, &#39;&gt;&#39;)
        str
    end

    # Now the low level matching functions

    def add_to_html( object )
        @html &lt;&lt; object.to_s
    end

    def html
        @html
    end

    def reset
        @html, @scanner = &quot;&quot; , StringScanner.new( @text )
        @aliases = {}
        @indent = 0
    end    
end
</code></pre>

</body>
</html>
